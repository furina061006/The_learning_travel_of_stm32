# 练习过的代码以及笔记
> 此project是新手跟着`江协科技`学习而做的,此markdown扮演了一种留存代码和笔记的角色
## 目录
- [练习过的代码以及笔记](#练习过的代码以及笔记)
  - [目录](#目录)
  - [点灯小弟](#点灯小弟)
    - [代码结构](#代码结构)
    - [keil5软件功能](#keil5软件功能)
  - [6-1 定时器定时中断](#6-1-定时器定时中断)
## 点灯小弟
```c
#include "stm32f10x.h"                  // Device header
 
 int main(void)
 {
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOC,&GPIO_InitStructure);
//	GPIO_SetBits(GPIOC, GPIO_Pin_13);
	GPIO_ResetBits(GPIOC, GPIO_Pin_13);
	while(1)
	{
		
	}
 }
 
```
今天功能实现上了解不算多,主要是摸索了些Keil5的软件功能,话不多说,上笔记!  :
### 代码结构
- 首先是`#include "stm32f10x.h"`,它是一个总的头文件,意思是里头有含一段 :
```C 
#ifdef USE_STDPERIPH_DRIVER//这里的`USE_STDPERIPH_DRIVER`,即使用标准外设
// 需要用keil5的魔术棒-> C\C++ -> define 填写`USE_STDPERIPH_DRIVER`,以全局宏定义`USE_STDPERIPH_DRIVER`,避免在不同源程序文件里重复定义,麻烦
  #include "stm32f10x_conf.h"
#endif
```
然后我们再打开这个`stm32f10x_conf.h`,里面会含一段 :
```C
/* Includes ------------------------------------------------------------------*/
/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
#include "stm32f10x_adc.h"
#include "stm32f10x_bkp.h"
#include "stm32f10x_can.h"
#include "stm32f10x_cec.h"
#include "stm32f10x_crc.h"
#include "stm32f10x_dac.h"
#include "stm32f10x_dbgmcu.h"
#include "stm32f10x_dma.h"
#include "stm32f10x_exti.h"
#include "stm32f10x_flash.h"
#include "stm32f10x_fsmc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_i2c.h"
#include "stm32f10x_iwdg.h"
#include "stm32f10x_pwr.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_rtc.h"
#include "stm32f10x_sdio.h"
#include "stm32f10x_spi.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_wwdg.h"
#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
```
这便是所有的标准库头文件了,这就是一个头文件能让我们使用所有标准库头文件的原因

- 每个函数的功能暂时还是不太清楚,但是幸亏跟着`江协科技`掌握了查找函数定义和应用的方法,~~这个是很基础的,只是我第一次知道这些~~
***
### keil5软件功能
- #### 项目视图(project view)
![alt text](./images/image.png)
这个视图我目前只知道两大作用 :
- **文件可视化** :
我向这个工程里加入了什么文件,这在我们了解我们需要和查找哪些文件时显得格外方便 

- **文件编译** :
keil5会把加入到项目视图的特定类型文件（比如`.c`）在构建`build`时一起进行编译
> 这里最需要注意的,`头文件.h`不包括在内
> 所以我们要自己把含`头文件`的文件夹加入环境变量`include path`内
![alt text](./images/image-1.png)

>关于项目视图,我一开始最不理解的,我以为它真的自己又建了个真实文件夹。实则不然，这个只起到可视化的作用，并不存在这些文件夹，充其量只有每个文件的地址？
真正的文件还在总工程文件夹里
![alt text](./images/image-2.png)
诺，就是这里的.\Start :.\User :.\Library,**这几个文件夹都是我自己额外建的，和project view没有一点关系**

## 6-1 定时器定时中断
```C
void Timer_Init(void)
{
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	
	TIM_InternalClockConfig(TIM2);//开启后默认是内部时钟，但写一下更稳妥。
	
	//设置定时器基本功能： 
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;//输入滤波的时钟分频，TIM_CKD_DIV1代表分频系数为1
	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;//CNT计数器的计数模式
	TIM_TimeBaseInitStruct.TIM_Period = 9999;//ARR的自动重装值,比实际目标值小1.
	TIM_TimeBaseInitStruct.TIM_Prescaler = 7199;//分频器的值，比分频系数小1.
	TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0;//重复计数器的值（高级计时器才有）
	TIM_TimeBaseInit(TIM2 , &TIM_TimeBaseInitStruct);//为了让PSC和ARR的值立刻生效会马上触发一次更新事件,顺带着会触发更新中断
	
	//清除更新中断标志位
	TIM_ClearFlag(TIM2 ,  TIM_FLAG_Update);
	
	//设置更新中断/事件
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);//开启更新中断到NVIC 的通路
	
	//选择NVIC优先级分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	//设置NVIC 的基本配置。
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;//     对TIM2_IRQn的通道
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//     				   开放
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStructure);
	
	//使能CNT计数器
	TIM_Cmd(TIM2, ENABLE);
	
}

```
- 第一段:
```C
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
// RCC_APB1PeriphClockCmd 复位和时钟控制APB1总线外设时钟命令 函数实现为:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
// assert_param 断言参数 宏实现为:
/**
 * @brief 会在函数开头对传入的参数做合法性检查
 * @note 仅在调试阶段有用,在发布阶段相当于空白
 */
// 调试阶段 ↓
#define USE_FULL_ASSERT    // 在 stm32f4xx.h 或 main.c 中定义,由此开启断言.
#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
// 如果 expr 为真（参数合法）→ 什么也不做
// 如果 expr 为假（参数非法）→ 调用 assert_failed() 函数（通常进入死循环或打印错误）

// 发布阶段 ↓
 #define assert_param(expr) ((void)0)
// ((void)0)是一种安全的“空语句”写法,表示“这里故意什么都不做”，而不是遗漏了实现。不会引起编译器的警告.

// IS_RCC_APB1_PERIPH 是否为RCC_APB1_PERIPH 宏实现为:
/**
 * @brief 会在函数开头对传入的参数做合法性检查
 * @note 首先要知道 PERIPH 的合法取值是0x00000n00,其中n = 1/2/4/8, n可与任意 0 互换位置.但n在某几位时, n != 1/2/4/8 的其中几个
 * 比如 0x00000001 就是一个合法取值,但是 0x00000400 就是非法取值.
 */
#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x81013600) == 0x00) && ((PERIPH) != 0x00))
宏分为两部分:
一: (((PERIPH) & 0x81013600) == 0x00) 
0x81013600 = 0b10000001000000010011011000000000
0x1 = 0b0001
0x2 = 0b0010
0x4 = 0b0100
0x8 = 0b1000
0b10000001000000010011011000000000 中的 1 正是 PERIPH 的非法取值.
当 PERIPH 取合法值的时候, 值就为 0x00.

二: ((PERIPH) != 0x00)
因为 0x00 同样第一部分为 TRUE , 但是 0x00是非法值. 第二部分就是剔除 0x00 的.

//IS_FUNCTIONAL_STATE 同理,不再赘述.

/**
 * @brief 对外设进行使能或失能
 * @note  
 */
if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;// 对应位置 0, 使能 
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;//对应位置 1 ,失能
  }
APB1ENR APB1使能寄存器 这两行的操作就是对此寄存器的某一位进行置位.
RCC_APB1Periph 对应外设位为 1,其余位为 0.

```
- 第二段
```C
TIM_InternalClockConfig(TIM2);
// TIM_InternalClockConfig 定时器内部时钟配置 函数实现为:
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
}
SMCR 系统模式控制寄存器 
#define  TIM_SMCR_SMS           ((uint16_t)0x0007)  //0x7 = 0111
结果就是SMCR寄存器的最后三位为0 ，从模式失能，从而分频器接入内部时钟。

至于为什么这一行 用 &= ....~TIM_SMCR_SMS 这种双重否定表肯定的方法,原因就是
这一行的目的是:  有0则0.
如果用 |= ....TIM_SMCR_SMS   目的就是:   有1则1.
```

- 第三段
```C
IM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;//输入滤波的时钟分频，TIM_CKD_DIV1代表分频系数为1
TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;//CNT计数器的计数模式
TIM_TimeBaseInitStruct.TIM_Period = 9999;//ARR的自动重装值,比实际目标值小1.
TIM_TimeBaseInitStruct.TIM_Prescaler = 7199;//分频器的值，比分频系数小1.
TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0;//重复计数器的值（高级计时器才有）
TIM_TimeBaseInit(TIM2 , &TIM_TimeBaseInitStruct);//为了让PSC和ARR的值立刻生效会马上触发一次更新事件,顺带着会触发更新中断

// 前面的结构体配置不讲了,直接讲时基单元初始化
TIM_TimeBaseInit(TIM2 , &TIM_TimeBaseInitStruct);
/**
 * @brief 根据传入的配置参数，初始化定时器的核心时基相关寄存器（CR1/ARR/PSC/RCR/EGR），是所有定时器定时 / 计数功能的初始化入口。
 * @note 
 */
// TIM_TimeBaseInit 时基单元初始化 函数实现如下:
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  // 1. 定义临时变量temp+CR1 → tmpcr1，存放CR1寄存器的当前值，避免直接操作寄存器导致的位操作冲突
  uint16_t tmpcr1 = 0;

  // 2. 参数合法性断言检查（调试阶段生效，量产关闭），防止传入非法参数导致硬件异常
  // 检查TIMx是否为STM32合法的定时器外设（TIM1~TIM17等，按芯片型号定）
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  // 检查计数模式是否合法（仅支持向上/向下/中央对齐1/2/3，共5种合法模式）
  assert_param(IS_TIM_COUNTER_MODE(TIMx->TIM_CounterMode));
  // 检查时钟分频值是否合法（仅支持不分频/2分频/4分频，对应TIM_CKD_DIV1/2/4）
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  // 3. 读取定时器CR1寄存器的当前值到临时变量
  // 原因：CR1是16位控制寄存器，包含多个功能位（如CEN使能位、URS更新源位），所谓的 TIMx->CR1 其实是一个32位的二进制数.
  // 直接操作会覆盖其他已配置的位，因此先读入临时变量，仅修改需要的位，最后写回
  tmpcr1 = TIMx->CR1;  

  // 4. 配置【计数模式】：仅对「高级定时器(TIM1/TIM8)」和「通用定时器(TIM2~TIM5)」生效
  // 基础定时器(TIM6/TIM7)无计数模式选择，仅支持向上计数，因此跳过此段
  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    // 4.1 先清空CR1中与计数模式相关的位：DIR位（方向位，0向上/1向下）、CMS位（中央对齐模式位，2位）
    // ~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS))：按位取反，生成掩码（DIR和CMS位为0，其他位为1）
    // 按位与&：保留tmpcr1中其他位，仅清空DIR和CMS位，避免影响其他功能        DIR   CMS
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));//现在  0     0 
    // 4.2 将配置的计数模式写入tmpcr1的DIR和CMS位，其他位保持不变
    // TIM_CounterMode的值是标准库预定义的宏，刚好对应DIR+CMS的合法组合值     DIR   CMS
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;// 现在  TIM_CounterMode(00/01/10/11)
  }
 
  // 5. 配置【时钟分频(CKD)】：仅对「非基础定时器(TIM6/TIM7)」生效
  // 基础定时器无输入捕获/比较功能，无需配置采样时钟分频，因此跳过此段
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    // 5.1 先清空CR1中的CKD位（2位，时钟分频位），掩码方式避免影响其他位
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    // 5.2 将配置的时钟分频值写入CKD位
    // CKD用于设置定时器内部采样时钟（针对输入捕获/比较）与定时器时钟的分频比，提升抗干扰性
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
  }

  // 6. 将修改后的临时变量tmpcr1写回CR1寄存器，完成CR1的最终配置
  // 此时CR1中仅修改了「计数模式」和「时钟分频」，其他原有位保持不变
  TIMx->CR1 = tmpcr1;

  // 7. 设置【自动重装值(ARR)】：所有定时器均支持
  // ARR是定时器的自动重装寄存器，计数器计数到ARR值时，会触发「更新事件」（溢出/下溢）
  // TIM_Period是开发者配置的周期值，直接写入ARR，决定定时器的计数周期（定时时长 = (PSC+1)*(ARR+1)/定时器时钟频率）
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 
  // 8. 设置【预分频系数(PSC)】：所有定时器均支持
  // PSC是16位预分频寄存器，定时器时钟会被分频为：定时器时钟/(PSC+1)
  // 例：定时器时钟72MHz，PSC=7199，则分频后时钟为72M/(7199+1)=10kHz，计数器每100us加1
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    
  // 9. 设置【重复计数器(RCR)】：仅对「高级定时器(TIM1/TIM8/TIM15~TIM17)」生效
  // 通用/基础定时器无RCR寄存器，因此跳过此段
  // RCR作用：计数器溢出RCR+1次后，才会触发更新事件和PWM输出更新，用于生成多脉冲PWM
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
  {
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
  }

  // 10. 生成【立即更新事件】：强制重载PSC和RCR的值，让配置立即生效
  // TIMx->EGR = TIM_PSCReloadMode_Immediate; 等价于 TIMx->EGR = TIM_EGR_UG;
  // 原理：
  // - PSC和RCR寄存器的修改默认在「下一次更新事件」后才生效，若等待自然更新会导致配置延迟
  // - EGR是事件生成寄存器，置位UG位（更新生成位）会强制生成一次更新事件，无中断无标志位
  // - 此操作会让PSC（预分频）和RCR（重复计数器）的值立即加载到工作寄存器，ARR则根据CR1的ARPE位决定（ARPE=1则需更新事件，ARPE=0立即生效）
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
}
```
- 第四段
```C
TIM_ClearFlag(TIM2 ,  TIM_FLAG_Update);
// TIM_ClearFlag 定时器清除标志 函数实现为：
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
  // 把相应位清零。
}
```
- 第五段
```c
TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);//开启更新中断到 NVIC 的通路
// TIM_ITConfig 定时器中断配置 函数实现为：
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
  }
}
// 与第一段一致，不赘述
```
- 第六段
```C
NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
// NVIC_PriorityGroupConfig NVIC优先级分组配置 函数实现
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
}
// AIRCR_VECTKEY_MASK  应用中断和复位控制寄存器_向量密钥_掩码
// 加这个是为了防止电路跑通的时候，乱码飞过来把设置改了
```
- 第七段
```C
NVIC_InitTypeDef NVIC_InitStructure;
NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;//     对TIM2_IRQn的通道
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//     				   开放
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
NVIC_Init(&NVIC_InitStructure);
// NVIC_Init NVIC初始化 函数实现为：
// 太长了... 总之也是读写寄存器，从而操作其他外设。
```
- 第八段：
```C
TIM_Cmd(TIM2, ENABLE);
TIM_Cmd 计时器使能 函数实现为：
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
  }
}
//其实和前面一样
```